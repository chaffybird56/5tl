// C Code


// Template for C6713 DSK and AIC23 codec
#define CHIP_6713

#include "dsk6713.h"
#include "dsk6713_aic23.h" //
#include "math.h"

#include "with_barrier/data_trans.h"
//#include "data_rec.h"
#include "with_barrier/data_dechirp.h"

#include "FFT_helper.h"

int USE_MTI = 0;

COMPLEX mti_out[PTS];		//MTI output
double mti_h[8];            //[NUM_CHIRPS];

DSK6713_AIC23_CodecHandle hCodec;							// Codec handle
DSK6713_AIC23_Config config = DSK6713_AIC23_DEFAULTCONFIG;  // Codec configuration with default settings

///////////////////////////////////
int interrupt_count = 0;
double MAX_SIGNAL_VALUE = 0;

void initialize();
short convert_double_to_short_for_output(double max_value, double input_value);

double hanning_window(int n, int N){
	return 0.5*(1- cos((2*3.1415*n)/N));
}

void prepare_fft_data(COMPLEX* data, int N, int chirp_num){ //chrip_num: 0 to NUM_CHIRPS-1
	int i;
	double w_h;
	for (i =0; i< N; i++)
	{
		if (i < NUM_SAMPLES_PER_CHIRP)
		{
			w_h = hanning_window(i, N-1);
			data[i].real = dechirp_real[chirp_num*NUM_SAMPLES_PER_CHIRP+i];
			                            //*w_h;
			data[i].imag = dechirp_img[chirp_num*NUM_SAMPLES_PER_CHIRP+i];
			                           //*w_h;
		}
		else
		{
			data[i].real = 0;
			data[i].imag = 0;
		}
	}
}



void single_chirp_processing(int chirp_num)
{	
	prepare_fft_data(data_fft, PTS, chirp_num);	

	FFT(data_fft, w_fft, PTS);
}

int set_mti_h()
{
	int filter_len = 3;
	
	if (filter_len == 3)
	{
		mti_h[0] = 1;
		mti_h[1] = -2;
		mti_h[2] = 1;
	}
	else
	{
		mti_h[0] = 1;
		mti_h[1] = -1;		
	}
	
	return filter_len;
}

void mti_processing()
{
	int filter_len = set_mti_h();
	
	int i;
	for (i = 0; i<PTS; i++)
	{
		mti_out[i].real = 0;
		mti_out[i].imag = 0;
	}
	
	int p;
	int slow_sample = NUM_CHIRPS-1;//filter_len-1;
	for (p = 0; p<filter_len; p++)
	{	
		single_chirp_processing(slow_sample-p);
		for (i = 0; i < PTS; i++)
		{
			mti_out[i].real += mti_h[p]*data_fft[i].real;
			mti_out[i].imag += mti_h[p]*data_fft[i].imag;
		}
	}
}

void main()
{
	interrupt_count =0;	
	
	initialize();
		
	prepare_w_fft(w_fft, PTS);
	
	if (USE_MTI){
		mti_processing();
	}
	else{
		single_chirp_processing(0);
	}
	
	MAX_SIGNAL_VALUE = 0; //for c_int11 to recalculate the max value
	while(1);					// main loop - do nothing but wait for interrupts
}

/** interrupt service routine */
interrupt void c_int11()		
{
	int num_gaps_to_insert = 50;	
		
	double sig = 0;
	if (interrupt_count < PTS){
	// Note: do not use pow(), it has some issue
		if (USE_MTI){
			sig = sqrt(mti_out[interrupt_count].real*mti_out[interrupt_count].real + mti_out[interrupt_count].imag*mti_out[interrupt_count].imag);		
		}
		else{
			sig = sqrt(data_fft[interrupt_count].real*data_fft[interrupt_count].real + data_fft[interrupt_count].imag*data_fft[interrupt_count].imag);
		}
	}
	else if (interrupt_count < PTS + num_gaps_to_insert){
		sig = -0.5*MAX_SIGNAL_VALUE;//0;	
	}
	
	interrupt_count++;
	if (interrupt_count >= NUM_SAMPLES + num_gaps_to_insert){
		interrupt_count = 0;
	}
	
	if (sig > MAX_SIGNAL_VALUE){
		MAX_SIGNAL_VALUE = sig;
	}		
	
	short sig_out = convert_double_to_short_for_output(MAX_SIGNAL_VALUE, sig);
	
	/* DO NOT MODIFY ANYTHING BELOW */
	sig_out = -1*sig_out; //Board inverts the signal from the DAC.
	
	union {Uint32 stereo; short channel[2];} audio;	
	audio.channel[1] = sig_out;	// insert left channel
	audio.channel[0] = sig_out;	// insert right channel
	MCBSP_write(DSK6713_AIC23_DATAHANDLE, audio.stereo); // write stereo audio	
}

/* DO NOT MODIFY ANYTHING BELOW */
void vectors();         // external function

short convert_double_to_short_for_output(double max_value, double input_value)
{	
	short MAX_POSITIVE_VALUE = 32700;//32767
	
	if (input_value > max_value)
		input_value = max_value;
	
	short result = (short)(MAX_POSITIVE_VALUE/max_value*input_value);
	
	return result;
}

void initialize()
{
	// initialize dsp
	DSK6713_init();		//call BSL to init DSK-EMIF,PLL)

	DSK6713_LED_init();

	// initialize AIC23 peripheral
	hCodec = DSK6713_AIC23_openCodec(0, &config);	//handle(pointer) to codec
	DSK6713_AIC23_setFreq(hCodec, DSK6713_AIC23_FREQ_8KHZ);//set sample rate
	// Configure buffered serial ports for 32 bit operation
	// This allows transfer of both right and left channels in one read/write
	MCBSP_FSETS(SPCR1, RINTM, FRM);
	MCBSP_FSETS(SPCR1, XINTM, FRM);
	MCBSP_FSETS(RCR1, RWDLEN1, 32BIT);
	MCBSP_FSETS(XCR1, XWDLEN1, 32BIT);
	MCBSP_start(DSK6713_AIC23_DATAHANDLE, MCBSP_XMIT_START | MCBSP_RCV_START |
			MCBSP_SRGR_START | MCBSP_SRGR_FRAMESYNC, 220);// re-start data channel

	// initialize interrupt
	Uint32 CODECEventId;
	IRQ_globalDisable();		// disable interrupts
	CODECEventId=MCBSP_getXmtEventId(DSK6713_AIC23_codecdatahandle);// McBSP1 Xmit
	IRQ_setVecs(vectors);    	// point to the IRQ vector table
	IRQ_map(CODECEventId,11);	// Maps an event to a physical interrupt
	IRQ_reset(CODECEventId); 	// reset codec INT 11
	IRQ_globalEnable();			// Globally enables interrupts
	IRQ_nmiEnable();			// Enables the non-maskable interrupts
	IRQ_enable(CODECEventId);	// enable CODEC eventXmit INT11
	MCBSP_write(DSK6713_AIC23_DATAHANDLE,0);// start interrupt by outputting a sample
}

